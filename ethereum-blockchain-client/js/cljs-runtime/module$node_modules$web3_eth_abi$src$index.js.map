{
"version":3,
"file":"module$node_modules$web3_eth_abi$src$index.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/web3-eth-abi/src/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$web3_eth_abi$src$index\"] = function(global,require,module,exports) {\n/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\n\nvar _ = require('underscore');\nvar utils = require('web3-utils');\n\nvar EthersAbi = require('ethers/utils/abi-coder').AbiCoder;\nvar ethersAbiCoder = new EthersAbi(function (type, value) {\n    if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n\n// result method\nfunction Result() {\n}\n\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n\n    return utils.sha3(functionName).slice(0, 10);\n};\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n\n    return utils.sha3(functionName);\n};\n\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    return ethersAbiCoder.encode(\n        this.mapTypes(types),\n        params.map(function (param) {\n            if (utils.isBN(param) || utils.isBigNumber(param)) {\n                return param.toString(10);\n            }\n\n            return param;\n        })\n    );\n};\n\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(\n                Object.assign(\n                    self.mapStructNameAndType(structName),\n                    {\n                        components: self.mapStructToCoderFormat(type[structName])\n                    }\n                )\n            );\n\n            return;\n        }\n\n        mappedTypes.push(type);\n    });\n\n    return mappedTypes;\n};\n\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n\n    return {type: type, name: structName};\n};\n\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(\n                Object.assign(\n                    self.mapStructNameAndType(key),\n                    {\n                        components: self.mapStructToCoderFormat(struct[key])\n                    }\n                )\n            );\n\n            return;\n        }\n\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n\n    return components;\n};\n\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error(\n            'Returned values aren\\'t valid, did it run Out of Gas? ' +\n            'You might also see this error if you are not using the ' +\n            'correct ABI for the contract you are retrieving data from, ' +\n            'requesting data from a block number that does not exist, ' +\n            'or querying a node which is not fully synced.'\n        );\n    }\n\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''));\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        decodedValue = (decodedValue === '0x') ? null : decodedValue;\n\n        returnValue[i] = decodedValue;\n\n        if (_.isObject(output) && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n\n        returnValue.__length__++;\n    });\n\n    return returnValue;\n};\n\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = _.isArray(topics) ? topics : [topics];\n\n    data = data || '';\n\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n\n    // TODO check for anonymous logs?\n\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        } else {\n            notIndexedInputs[i] = input;\n        }\n    });\n\n\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParameters(notIndexedInputs, nonIndexedData) : [];\n\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n\n\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n\n        returnValue.__length__++;\n    });\n\n    return returnValue;\n};\n\nvar coder = new ABICoder();\n\nmodule.exports = coder;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Result","_","utils","ethersAbiCoder","AbiCoder","type","value","match","isArray","isObject","constructor","name","toString","ABICoder","prototype","encodeFunctionSignature","ABICoder.prototype.encodeFunctionSignature","functionName","_jsonInterfaceMethodToString","sha3","slice","encodeEventSignature","ABICoder.prototype.encodeEventSignature","encodeParameter","ABICoder.prototype.encodeParameter","param","encodeParameters","ABICoder.prototype.encodeParameters","types","params","encode","mapTypes","map","isBN","isBigNumber","ABICoder.prototype.mapTypes","self","mappedTypes","forEach","isSimplifiedStructFormat","structName","Object","keys","push","assign","mapStructNameAndType","components","mapStructToCoderFormat","ABICoder.prototype.isSimplifiedStructFormat","ABICoder.prototype.mapStructNameAndType","indexOf","ABICoder.prototype.mapStructToCoderFormat","struct","key","encodeFunctionCall","ABICoder.prototype.encodeFunctionCall","jsonInterface","inputs","replace","decodeParameter","ABICoder.prototype.decodeParameter","bytes","decodeParameters","ABICoder.prototype.decodeParameters","outputs","length","Error","res","decode","returnValue","__length__","output","i","decodedValue","decodeLog","ABICoder.prototype.decodeLog","data","topics","_this","notIndexedInputs","indexedParams","topicCount","input","indexed","find","staticType","notIndexedParams","nonIndexedData","coder"]
}
