shadow$provide.module$node_modules$ethereumjs_util$dist$account=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var assert=require("module$node_modules$assert$assert"),ethjsUtil=require("module$node_modules$ethjs_util$lib$index"),secp256k1=require("module$node_modules$secp256k1$elliptic"),BN=require("module$node_modules$bn_DOT_js$lib$bn"),bytes_1=require("module$node_modules$ethereumjs_util$dist$bytes"),
hash_1=require("module$node_modules$ethereumjs_util$dist$hash");exports.zeroAddress=function(){var addr=bytes_1.zeros(20);return bytes_1.bufferToHex(addr)};exports.isValidAddress=function(address){return/^0x[0-9a-fA-F]{40}$/.test(address)};exports.isZeroAddress=function(address){return exports.zeroAddress()===bytes_1.addHexPrefix(address)};exports.toChecksumAddress=function(address,eip1191ChainId){address=ethjsUtil.stripHexPrefix(address).toLowerCase();eip1191ChainId=hash_1.keccak((void 0!==eip1191ChainId?
eip1191ChainId.toString()+"0x":"")+address).toString("hex");for(var ret="0x",i=0;i<address.length;i++)ret=8<=parseInt(eip1191ChainId[i],16)?ret+address[i].toUpperCase():ret+address[i];return ret};exports.isValidChecksumAddress=function(address,eip1191ChainId){return exports.isValidAddress(address)&&exports.toChecksumAddress(address,eip1191ChainId)===address};exports.generateAddress=function(from,nonce){from=bytes_1.toBuffer(from);nonce=new BN(nonce);return nonce.isZero()?hash_1.rlphash([from,null]).slice(-20):
hash_1.rlphash([from,Buffer.from(nonce.toArray())]).slice(-20)};exports.generateAddress2=function(from,salt,initCode){from=bytes_1.toBuffer(from);salt=bytes_1.toBuffer(salt);initCode=bytes_1.toBuffer(initCode);assert(20===from.length);assert(32===salt.length);return hash_1.keccak256(Buffer.concat([Buffer.from("ff","hex"),from,salt,hash_1.keccak256(initCode)])).slice(-20)};exports.isPrecompiled=function(address){address=bytes_1.unpad(address);return 1===address.length&&1<=address[0]&&8>=address[0]};
exports.isValidPrivate=function(privateKey){return secp256k1.privateKeyVerify(privateKey)};exports.isValidPublic=function(publicKey,sanitize){void 0===sanitize&&(sanitize=!1);return 64===publicKey.length?secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]),publicKey])):sanitize?secp256k1.publicKeyVerify(publicKey):!1};exports.pubToAddress=function(pubKey,sanitize){void 0===sanitize&&(sanitize=!1);pubKey=bytes_1.toBuffer(pubKey);sanitize&&64!==pubKey.length&&(pubKey=secp256k1.publicKeyConvert(pubKey,
!1).slice(1));assert(64===pubKey.length);return hash_1.keccak(pubKey).slice(-20)};exports.publicToAddress=exports.pubToAddress;exports.privateToAddress=function(privateKey){return exports.publicToAddress(exports.privateToPublic(privateKey))};exports.privateToPublic=function(privateKey){privateKey=bytes_1.toBuffer(privateKey);return secp256k1.publicKeyCreate(privateKey,!1).slice(1)};exports.importPublic=function(publicKey){publicKey=bytes_1.toBuffer(publicKey);64!==publicKey.length&&(publicKey=secp256k1.publicKeyConvert(publicKey,
!1).slice(1));return publicKey}}
//# sourceMappingURL=module$node_modules$ethereumjs_util$dist$account.js.map
