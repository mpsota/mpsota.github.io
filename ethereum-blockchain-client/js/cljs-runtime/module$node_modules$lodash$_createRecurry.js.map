{
"version":3,
"file":"module$node_modules$lodash$_createRecurry.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,0CAAA,CAA8D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAAA,IAClGC,WAAaH,OAAA,CAAQ,wCAAR,CADqF,CAElGI,QAAUJ,OAAA,CAAQ,qCAAR,CAFwF,CAGlGK,gBAAkBL,OAAA,CAAQ,6CAAR,CAqDtBC,OAAAC,QAAA,CA1BAI,QAAsB,CAACC,IAAD,CAAOC,OAAP,CAAgBC,QAAhB,CAA0BC,WAA1B,CAAuCC,OAAvC,CAAgDC,QAAhD,CAA0DC,OAA1D,CAAmEC,MAAnE,CAA2EC,GAA3E,CAAgFC,KAAhF,CAAuF,CAAA,IACvGC,QAAUT,OAAVS,CAtBgBC,CA6BpBV,QAAA,EADAA,OACA,EADYS,OAAA,CA3BUE,EA2BV,CA1BgBC,EA2B5B,GAAW,EAAEH,OAAA,CA3BeG,EA2Bf,CA5BSD,EA4BX,CAELX,QAAN,CAhC0Ba,CAgC1B,GACEb,OADF,EACa,EADb,CAGIc,QAAAA,CAAU,CACZf,IADY;AACNC,OADM,CACGG,OADH,CATIM,OAAAM,CAAUX,QAAVW,CAAqBC,IAAAA,EASzB,CAXGP,OAAAQ,CAAUZ,OAAVY,CAAoBD,IAAAA,EAWvB,CARSP,OAAAS,CAAUF,IAAAA,EAAVE,CAAsBd,QAQ/B,CAVQK,OAAAU,CAAUH,IAAAA,EAAVG,CAAsBd,OAU9B,CAEKC,MAFL,CAEaC,GAFb,CAEkBC,KAFlB,CAKVY,SAAAA,CAASnB,QAAAoB,MAAA,CAAeL,IAAAA,EAAf,CAA0BF,OAA1B,CACTnB,WAAA,CAAWI,IAAX,CAAJ,EACEH,OAAA,CAAQwB,QAAR,CAAgBN,OAAhB,CAEFM,SAAAlB,YAAA,CAAqBA,WACrB,OAAOL,gBAAA,CAAgBuB,QAAhB,CAAwBrB,IAAxB,CAA8BC,OAA9B,CAvBoG,CA9BP;",
"sources":["node_modules/lodash/_createRecurry.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$lodash$_createRecurry\"] = function(global,require,module,exports) {\nvar isLaziable = require('./_isLaziable'),\n    setData = require('./_setData'),\n    setWrapToString = require('./_setWrapToString');\n\n/** Used to compose bitmasks for function metadata. */\nvar WRAP_BIND_FLAG = 1,\n    WRAP_BIND_KEY_FLAG = 2,\n    WRAP_CURRY_BOUND_FLAG = 4,\n    WRAP_CURRY_FLAG = 8,\n    WRAP_PARTIAL_FLAG = 32,\n    WRAP_PARTIAL_RIGHT_FLAG = 64;\n\n/**\n * Creates a function that wraps `func` to continue currying.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {Function} wrapFunc The function to create the `func` wrapper.\n * @param {*} placeholder The placeholder value.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to prepend to those provided to\n *  the new function.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n  var isCurry = bitmask & WRAP_CURRY_FLAG,\n      newHolders = isCurry ? holders : undefined,\n      newHoldersRight = isCurry ? undefined : holders,\n      newPartials = isCurry ? partials : undefined,\n      newPartialsRight = isCurry ? undefined : partials;\n\n  bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n    bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n  }\n  var newData = [\n    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n    newHoldersRight, argPos, ary, arity\n  ];\n\n  var result = wrapFunc.apply(undefined, newData);\n  if (isLaziable(func)) {\n    setData(result, newData);\n  }\n  result.placeholder = placeholder;\n  return setWrapToString(result, func, bitmask);\n}\n\nmodule.exports = createRecurry;\n\n};"],
"names":["shadow$provide","global","require","module","exports","isLaziable","setData","setWrapToString","createRecurry","func","bitmask","wrapFunc","placeholder","thisArg","partials","holders","argPos","ary","arity","isCurry","WRAP_CURRY_FLAG","WRAP_PARTIAL_FLAG","WRAP_PARTIAL_RIGHT_FLAG","WRAP_CURRY_BOUND_FLAG","newData","newPartials","undefined","newHolders","newPartialsRight","newHoldersRight","result","apply"]
}
