{
"version":3,
"file":"module$node_modules$web3_core_method$src$index.js",
"lineCount":29,
"mappings":"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",
"sources":["node_modules/web3-core-method/src/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$web3_core_method$src$index\"] = function(global,require,module,exports) {\n/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\n'use strict';\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar Method = function Method(options) {\n\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n\n    this.requestManager = options.requestManager;\n\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n    this.handleRevert = options.handleRevert;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    func.call = this.call;\n\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n\n    return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    func.call = this.call;\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    } else {\n        obj[name[0]] = func;\n    }\n};\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n\n    if (!this.inputFormatter) {\n        return args;\n    }\n\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n\n    if (_.isArray(result)) {\n        return result.map(function (res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n        });\n    } else {\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\n    }\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n\n    return payload;\n};\n\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this,\n        promiseResolved = false,\n        canUnsubscribe = true,\n        timeoutCount = 0,\n        confirmationCount = 0,\n        intervalId = null,\n        lastBlock = null,\n        receiptJSON = '',\n        gasProvided = (_.isObject(payload.params[0]) && payload.params[0].gas) ? payload.params[0].gas : null,\n        isContractDeployment = _.isObject(payload.params[0]) &&\n            payload.params[0].data &&\n            payload.params[0].from &&\n            !payload.params[0].to,\n        hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n                return !!val;\n            }],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads', // replace subscription with this name\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _.each(_ethereumCalls, function (mthd) {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n\n\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n            // catch error from requesting receipt\n                .catch(function (err) {\n                    sub.unsubscribe();\n                    promiseResolved = true;\n                    utils._fireError(\n                        {\n                            message: 'Failed to check for transaction receipt:',\n                            data: err\n                        },\n                        defer.eventEmitter,\n                        defer.reject\n                    );\n                })\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n                .then(async function (receipt) {\n                    if (!receipt || !receipt.blockHash) {\n                        throw new Error('Receipt missing or blockHash null');\n                    }\n\n                    // apply extra formatters\n                    if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                        receipt = method.extraFormatters.receiptFormatter(receipt);\n                    }\n\n                    // check if confirmation listener exists\n                    if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                        var block;\n\n                        // If there was an immediately retrieved receipt, it's already\n                        // been confirmed by the direct call to checkConfirmation needed\n                        // for parity instant-seal\n                        if (existingReceipt === undefined || confirmationCount !== 0) {\n                            if (isPolling) { // Check if actually a new block is existing on polling\n                                if (lastBlock) {\n                                    block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                    if (block) {\n                                        lastBlock = block;\n                                        defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                                    }\n                                } else {\n                                    block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                                }\n                            } else {\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                            }\n                        }\n\n                        if ((isPolling && block) || !isPolling) {\n                            confirmationCount++;\n                        }\n                        canUnsubscribe = false;\n\n                        if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\n                            sub.unsubscribe();\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n\n                    return receipt;\n                })\n                // CHECK for CONTRACT DEPLOYMENT\n                .then(async function (receipt) {\n\n                    if (isContractDeployment && !promiseResolved) {\n\n                        if (!receipt.contractAddress) {\n\n                            if (canUnsubscribe) {\n                                sub.unsubscribe();\n                                promiseResolved = true;\n                            }\n\n                            utils._fireError(\n                                errors.NoContractAddressFoundError(receipt),\n                                defer.eventEmitter,\n                                defer.reject,\n                                null,\n                                receipt\n                            );\n                            return;\n                        }\n\n                        var code;\n                        try {\n                            code = await _ethereumCall.getCode(receipt.contractAddress);\n                        } catch(err){\n                            // ignore;\n                        }\n\n                        if (!code) {\n                            return;\n                        }\n\n                        // If deployment is status.true and there was a real\n                        // bytecode string, assume it was successful.\n                        var deploymentSuccess = receipt.status === true && hasBytecode;\n\n                        if (deploymentSuccess || code.length > 2) {\n                            defer.eventEmitter.emit('receipt', receipt);\n\n                            // if contract, return instance instead of receipt\n                            if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                            } else {\n                                defer.resolve(receipt);\n                            }\n\n                            // need to remove listeners, as they aren't removed automatically when succesfull\n                            if (canUnsubscribe) {\n                                defer.eventEmitter.removeAllListeners();\n                            }\n\n                        } else {\n                            utils._fireError(\n                                errors.ContractCodeNotStoredError(receipt),\n                                defer.eventEmitter,\n                                defer.reject,\n                                null,\n                                receipt\n                            );\n                        }\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                        }\n                        promiseResolved = true;\n                    }\n\n                    return receipt;\n                })\n                // CHECK for normal tx check for receipt only\n                .then(async function (receipt) {\n                    if (!isContractDeployment && !promiseResolved) {\n                        if (!receipt.outOfGas &&\n                            (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                            (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                            defer.eventEmitter.emit('receipt', receipt);\n                            defer.resolve(receipt);\n\n                            // need to remove listeners, as they aren't removed automatically when succesfull\n                            if (canUnsubscribe) {\n                                defer.eventEmitter.removeAllListeners();\n                            }\n\n                        } else {\n                            receiptJSON = JSON.stringify(receipt, null, 2);\n\n                            if (receipt.status === false || receipt.status === '0x0') {\n                                try {\n                                    var revertMessage = null;\n\n                                    if (method.handleRevert && method.call === 'eth_sendTransaction') {\n                                        // Get revert reason string with eth_call\n                                        revertMessage = await method.getRevertReason(\n                                            payload.params[0],\n                                            receipt.blockNumber\n                                        );\n\n                                        if (revertMessage) { // Only throw a revert error if a revert reason is existing\n                                            utils._fireError(\n                                                errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt),\n                                                defer.eventEmitter,\n                                                defer.reject,\n                                                null,\n                                                receipt\n                                            );\n                                        } else {\n                                            throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                        }\n                                    } else {\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                    }\n                                } catch (error) {\n                                    // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                                    utils._fireError(\n                                        errors.TransactionRevertedWithoutReasonError(receipt),\n                                        defer.eventEmitter,\n                                        defer.reject,\n                                        null,\n                                        receipt\n                                    );\n                                }\n                            } else {\n                                // Throw OOG if status is not existing and provided gas and used gas are equal\n                                utils._fireError(\n                                    errors.TransactionOutOfGasError(receipt),\n                                    defer.eventEmitter,\n                                    defer.reject,\n                                    null,\n                                    receipt\n                                );\n                            }\n                        }\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                        }\n                        promiseResolved = true;\n                    }\n\n                })\n                // time out the transaction if not mined after 50 blocks\n                .catch(function () {\n                    timeoutCount++;\n\n                    // check to see if we are http polling\n                    if (!!isPolling) {\n                        // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                        if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                            utils._fireError(\n                                errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'),\n                                defer.eventEmitter,\n                                defer.reject\n                            );\n                        }\n                    } else {\n                        if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                            utils._fireError(\n                                errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'),\n                                defer.eventEmitter,\n                                defer.reject\n                            );\n                        }\n                    }\n                });\n\n\n        } else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function (existingReceipt) {\n        // if provider allows PUB/SUB\n        if (_.isFunction(this.requestManager.provider.on)) {\n            _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n        } else {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n        }\n    }.bind(this);\n\n\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n        .then(function (receipt) {\n            if (receipt && receipt.blockHash) {\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                    // We must keep on watching for new Blocks, if a confirmation listener is present\n                    startWatching(receipt);\n                }\n                checkConfirmation(receipt, false);\n\n            } else if (!promiseResolved) {\n                startWatching();\n            }\n        })\n        .catch(function () {\n            if (!promiseResolved) startWatching();\n        });\n\n};\n\n\nvar getWallet = function (from, accounts) {\n    var wallet = null;\n\n    // is index given\n    if (_.isNumber(from)) {\n        wallet = accounts.wallet[from];\n\n        // is account given\n    } else if (_.isObject(from) && from.address && from.privateKey) {\n        wallet = from;\n\n        // search in wallet for address\n    } else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n\n    return wallet;\n};\n\nMethod.prototype.buildCall = function () {\n    var method = this,\n        isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'), // || method.call === 'personal_sendTransaction'\n        isCall = (method.call === 'eth_call');\n\n    // actual send function\n    var send = function () {\n        var defer = promiEvent(!isSendTx),\n            payload = method.toPayload(Array.prototype.slice.call(arguments));\n\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            if (method.handleRevert && !err && isCall && (method.isRevertReasonString(result) && method.abiCoder)) {\n                var reason = method.abiCoder.decodeParameter('string', '0x' + result.substring(10));\n                var signature = 'Error(String)';\n\n                utils._fireError(\n                    errors.RevertInstructionError(reason, signature),\n                    defer.eventEmitter,\n                    defer.reject,\n                    payload.callback,\n                    {\n                        reason: reason,\n                        signature: signature\n                    }\n                );\n\n                return;\n            }\n\n            try {\n                result = method.formatOutput(result);\n            } catch (e) {\n                err = e;\n            }\n\n            if (result instanceof Error) {\n                err = result;\n            }\n\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            } else {\n                if (err.error) {\n                    err = err.error;\n                }\n\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n\n            // return PROMISE\n            if (!isSendTx) {\n                if (!err) {\n                    defer.resolve(result);\n                }\n\n                // return PROMIEVENT\n            } else {\n                defer.eventEmitter.emit('transactionHash', result);\n\n                method._confirmTransaction(defer, result, payload);\n            }\n\n        };\n\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function (sign) {\n\n            var signedPayload = _.extend({}, payload, {\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            });\n\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n\n\n        var sendRequest = function (payload, method) {\n\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((_.isObject(tx)) ? tx.from : null, method.accounts);\n\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var txOptions = _.omit(tx, 'from');\n\n                        if (method.defaultChain && !txOptions.chain) {\n                            txOptions.chain = method.defaultChain;\n                        }\n\n                        if (method.defaultHardfork && !txOptions.hardfork) {\n                            txOptions.hardfork = method.defaultHardfork;\n                        }\n\n                        if (method.defaultCommon && !txOptions.common) {\n                            txOptions.common = method.defaultCommon;\n                        }\n\n                        return method.accounts.signTransaction(txOptions, wallet.privateKey)\n                            .then(sendSignedTx)\n                            .catch(function (err) {\n                                if (_.isFunction(defer.eventEmitter.listeners) && defer.eventEmitter.listeners('error').length) {\n                                    defer.eventEmitter.emit('error', err);\n                                    defer.eventEmitter.removeAllListeners();\n                                    defer.eventEmitter.catch(function () {\n                                    });\n                                }\n                                defer.reject(err);\n                            });\n                    }\n\n                    // ETH_SIGN\n                } else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n\n\n                }\n            }\n\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n\n        // Send the actual transaction\n        if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n\n            getGasPrice(function (err, gasPrice) {\n\n                if (gasPrice) {\n                    payload.params[0].gasPrice = gasPrice;\n                }\n                sendRequest(payload, method);\n            });\n\n        } else {\n            sendRequest(payload, method);\n        }\n\n\n        return defer.eventEmitter;\n    };\n\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\n\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n    var self = this;\n\n    return new Promise(function (resolve, reject) {\n        (new Method({\n            name: 'call',\n            call: 'eth_call',\n            params: 2,\n            abiCoder: self.abiCoder,\n            handleRevert: true\n        }))\n            .createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber))\n            .then(function () {\n                resolve(false);\n            })\n            .catch(function (error) {\n                if (error.reason) {\n                    resolve({\n                        reason: error.reason,\n                        signature: error.signature\n                    });\n                } else {\n                    reject(error);\n                }\n            });\n    });\n};\n\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n    return _.isString(data) && ((data.length - 2) / 2) % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\n\nmodule.exports = Method;\n\n};"],
"names":["shadow$provide","global","require","module","exports","_","errors","formatters","utils","promiEvent","Subscriptions","subscriptions","Method","options","call","name","Error","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","abiCoder","requestManager","accounts","defaultBlock","defaultAccount","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","defaultCommon","defaultChain","defaultHardfork","handleRevert","prototype","setRequestManager","Method.prototype.setRequestManager","createFunction","Method.prototype.createFunction","func","buildCall","attachToObject","Method.prototype.attachToObject","obj","split","length","getCall","Method.prototype.getCall","args","isFunction","extractCallback","Method.prototype.extractCallback","pop","validateArgs","Method.prototype.validateArgs","InvalidNumberOfParams","formatInput","Method.prototype.formatInput","_this","map","formatter","index","formatOutput","Method.prototype.formatOutput","result","isArray","res","toPayload","Method.prototype.toPayload","callback","payload","method","_confirmTransaction","Method.prototype._confirmTransaction","defer","promiseResolved","canUnsubscribe","timeoutCount","confirmationCount","intervalId","lastBlock","gasProvided","isObject","gas","isContractDeployment","data","from","to","hasBytecode","_ethereumCalls","inputBlockNumberFormatter","val","outputBlockFormatter","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","type","subscriptionName","_ethereumCall","each","mthd","checkConfirmation","existingReceipt","isPolling","err","blockHeader","sub","unsubscribe","_fireError","message","eventEmitter","reject","clearInterval","catch","resolve","getTransactionReceipt","then","receipt","block","blockHash","receiptFormatter","listeners","undefined","emit","getBlockByNumber","number","blockNumber","removeAllListeners","code","deploymentSuccess","contractAddress","NoContractAddressFoundError","getCode","status","contractDeployFormatter","ContractCodeNotStoredError","revertMessage","outOfGas","gasUsed","JSON","stringify","TransactionOutOfGasError","getRevertReason","TransactionRevertInstructionError","reason","signature","error","TransactionRevertedWithoutReasonError","TransactionError","startWatching","provider","on","subscribe","bind","setInterval","getWallet","isNumber","wallet","address","privateKey","toLowerCase","Method.prototype.buildCall","isSendTx","isCall","send","Array","slice","arguments","sendTxCallback","isRevertReasonString","decodeParameter","substring","RevertInstructionError","e","sendSignedTx","sign","signedPayload","extend","rawTransaction","sendRequest","tx","txOptions","omit","chain","hardfork","common","signTransaction","gasPrice","getGasPrice","request","Method.prototype.getRevertReason","self","Promise","numberToHex","Method.prototype.isRevertReasonString","isString","Method.prototype.request","format"]
}
