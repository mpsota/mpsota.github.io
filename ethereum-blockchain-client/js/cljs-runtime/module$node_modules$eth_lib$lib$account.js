shadow$provide.module$node_modules$eth_lib$lib$account=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer,_slicedToArray=function(){return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr)){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!i||_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{if(!_n&&_i["return"])_i["return"]()}finally{if(_d)throw _e;
}}return _arr}throw new TypeError("Invalid attempt to destructure non-iterable instance");}}(),Bytes=require("module$node_modules$eth_lib$lib$bytes"),Nat=require("module$node_modules$eth_lib$lib$nat");global=require("module$node_modules$elliptic$lib$elliptic");var rlp=require("module$node_modules$eth_lib$lib$rlp"),secp256k1=new global.ec("secp256k1");require=require("module$node_modules$eth_lib$lib$hash");var keccak256=require.keccak256,keccak256s=require.keccak256s,toChecksum=function(address){for(var addressHash=
keccak256s(address.slice(2)),checksumAddress="0x",i=0;40>i;i++)checksumAddress+=7<parseInt(addressHash[i+2],16)?address[i+2].toUpperCase():address[i+2];return checksumAddress},fromPrivate=function(privateKey){var buffer=new Buffer(privateKey.slice(2),"hex");buffer="0x"+secp256k1.keyFromPrivate(buffer).getPublic(!1,"hex").slice(2);buffer=keccak256(buffer);return{address:toChecksum("0x"+buffer.slice(-40)),privateKey:privateKey}},encodeSignature=function(_ref){_ref=_slicedToArray(_ref,3);return Bytes.flatten([_ref[1],
_ref[2],_ref[0]])},decodeSignature=function(hex){return[Bytes.slice(64,65,hex),Bytes.slice(0,32,hex),Bytes.slice(32,64,hex)]},makeSign=function(addToV){return function(hash,privateKey){hash=secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2),"hex")).sign(new Buffer(hash.slice(2),"hex"),{canonical:!0});return encodeSignature([Bytes.pad(1,Bytes.fromNumber(addToV+hash.recoveryParam)),Bytes.pad(32,Bytes.fromNat("0x"+hash.r.toString(16))),Bytes.pad(32,Bytes.fromNat("0x"+hash.s.toString(16)))])}};require=
makeSign(27);var recover=function(hash,signature){signature=decodeSignature(signature);signature={v:Bytes.toNumber(signature[0]),r:signature[1].slice(2),s:signature[2].slice(2)};hash="0x"+secp256k1.recoverPubKey(new Buffer(hash.slice(2),"hex"),signature,2>signature.v?signature.v:1-signature.v%2).encode("hex",!1).slice(2);hash=keccak256(hash);return toChecksum("0x"+hash.slice(-40))},transactionSigningData=function(tx){return rlp.encode([Bytes.fromNat(tx.nonce),Bytes.fromNat(tx.gasPrice),Bytes.fromNat(tx.gas),
tx.to.toLowerCase(),Bytes.fromNat(tx.value),tx.data,Bytes.fromNat(tx.chainId||"0x1"),"0x","0x"])};module.exports={create:function(entropy){entropy=keccak256(Bytes.concat(Bytes.random(32),entropy||Bytes.random(32)));entropy=Bytes.concat(Bytes.concat(Bytes.random(32),entropy),Bytes.random(32));entropy=keccak256(entropy);return fromPrivate(entropy)},toChecksum:toChecksum,fromPrivate:fromPrivate,sign:require,recover:recover,signTransaction:function(tx,privateKey){var signingData=transactionSigningData(tx);
tx=makeSign(2*Nat.toNumber(tx.chainId||"0x1")+35)(keccak256(signingData),privateKey);signingData=rlp.decode(signingData).slice(0,6).concat(decodeSignature(tx));return rlp.encode(signingData)},recoverTransaction:function(rawTransaction){var values=rlp.decode(rawTransaction);rawTransaction=encodeSignature(values.slice(6,9));var recovery=Bytes.toNumber(values[6]);recovery=35>recovery?[]:[Bytes.fromNumber(recovery-35>>1),"0x","0x"];values=values.slice(0,6).concat(recovery);values=rlp.encode(values);return recover(keccak256(values),
rawTransaction)},transactionSigningData:transactionSigningData,encodeSignature:encodeSignature,decodeSignature:decodeSignature}}
//# sourceMappingURL=module$node_modules$eth_lib$lib$account.js.map
