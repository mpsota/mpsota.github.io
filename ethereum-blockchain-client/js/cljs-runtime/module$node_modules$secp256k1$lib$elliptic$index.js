shadow$provide.module$node_modules$secp256k1$lib$elliptic$index=function(global,require,module,exports){function loadPublicKey(publicKey){var first=publicKey[0];switch(first){case 2:case 3:if(33!==publicKey.length)return null;var xBuffer=publicKey.slice(1,33);xBuffer=new BN(xBuffer);0<=xBuffer.cmp(ecparams.p)?first=null:(xBuffer=xBuffer.toRed(ecparams.red),publicKey=xBuffer.redSqr().redIMul(xBuffer).redIAdd(ecparams.b).redSqrt(),3===first!==publicKey.isOdd()&&(publicKey=publicKey.redNeg()),first=
ec.keyPair({pub:{x:xBuffer,y:publicKey}}));return first;case 4:case 6:case 7:if(65!==publicKey.length)return null;xBuffer=publicKey.slice(1,33);publicKey=publicKey.slice(33,65);xBuffer=new BN(xBuffer);publicKey=new BN(publicKey);0<=xBuffer.cmp(ecparams.p)||0<=publicKey.cmp(ecparams.p)?first=null:(xBuffer=xBuffer.toRed(ecparams.red),publicKey=publicKey.toRed(ecparams.red),6!==first&&7!==first||publicKey.isOdd()===(7===first)?(first=xBuffer.redSqr().redIMul(xBuffer),first=publicKey.redSqr().redISub(first.redIAdd(ecparams.b)).isZero()?
ec.keyPair({pub:{x:xBuffer,y:publicKey}}):null):first=null);return first;default:return null}}var Buffer=require("module$node_modules$safe_buffer$index").Buffer,createHash=require("module$node_modules$create_hash$browser"),BN=require("module$node_modules$bn_DOT_js$lib$bn");global=require("module$node_modules$elliptic$lib$elliptic").ec;var messages=require("module$node_modules$secp256k1$lib$messages_json"),ec=new global("secp256k1"),ecparams=ec.curve;exports.privateKeyVerify=function(privateKey){privateKey=
new BN(privateKey);return 0>privateKey.cmp(ecparams.n)&&!privateKey.isZero()};exports.privateKeyExport=function(privateKey,compressed){var d=new BN(privateKey);if(0<=d.cmp(ecparams.n)||d.isZero())throw Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL);return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed,!0))};exports.privateKeyNegate=function(privateKey){privateKey=new BN(privateKey);return privateKey.isZero()?Buffer.alloc(32):ecparams.n.sub(privateKey).umod(ecparams.n).toArrayLike(Buffer,
"be",32)};exports.privateKeyModInverse=function(privateKey){privateKey=new BN(privateKey);if(0<=privateKey.cmp(ecparams.n)||privateKey.isZero())throw Error(messages.EC_PRIVATE_KEY_RANGE_INVALID);return privateKey.invm(ecparams.n).toArrayLike(Buffer,"be",32)};exports.privateKeyTweakAdd=function(privateKey,tweak){tweak=new BN(tweak);if(0<=tweak.cmp(ecparams.n))throw Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);tweak.iadd(new BN(privateKey));0<=tweak.cmp(ecparams.n)&&tweak.isub(ecparams.n);if(tweak.isZero())throw Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
return tweak.toArrayLike(Buffer,"be",32)};exports.privateKeyTweakMul=function(privateKey,tweak){tweak=new BN(tweak);if(0<=tweak.cmp(ecparams.n)||tweak.isZero())throw Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL);tweak.imul(new BN(privateKey));tweak.cmp(ecparams.n)&&(tweak=tweak.umod(ecparams.n));return tweak.toArrayLike(Buffer,"be",32)};exports.publicKeyCreate=function(privateKey,compressed){var d=new BN(privateKey);if(0<=d.cmp(ecparams.n)||d.isZero())throw Error(messages.EC_PUBLIC_KEY_CREATE_FAIL);
return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed,!0))};exports.publicKeyConvert=function(publicKey,compressed){publicKey=loadPublicKey(publicKey);if(null===publicKey)throw Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);return Buffer.from(publicKey.getPublic(compressed,!0))};exports.publicKeyVerify=function(publicKey){return null!==loadPublicKey(publicKey)};exports.publicKeyTweakAdd=function(publicKey,tweak,compressed){publicKey=loadPublicKey(publicKey);if(null===publicKey)throw Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
tweak=new BN(tweak);if(0<=tweak.cmp(ecparams.n))throw Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);tweak=ecparams.g.mul(tweak).add(publicKey.pub);if(tweak.isInfinity())throw Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);return Buffer.from(tweak.encode(!0,compressed))};exports.publicKeyTweakMul=function(publicKey,tweak,compressed){publicKey=loadPublicKey(publicKey);if(null===publicKey)throw Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);tweak=new BN(tweak);if(0<=tweak.cmp(ecparams.n)||tweak.isZero())throw Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL);
return Buffer.from(publicKey.pub.mul(tweak).encode(!0,compressed))};exports.publicKeyCombine=function(publicKeys,compressed){for(var pairs=Array(publicKeys.length),i=0;i<publicKeys.length;++i)if(pairs[i]=loadPublicKey(publicKeys[i]),null===pairs[i])throw Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);publicKeys=pairs[0].pub;for(i=1;i<pairs.length;++i)publicKeys=publicKeys.add(pairs[i].pub);if(publicKeys.isInfinity())throw Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL);return Buffer.from(publicKeys.encode(!0,
compressed))};exports.signatureNormalize=function(signature){var r=new BN(signature.slice(0,32)),s=new BN(signature.slice(32,64));if(0<=r.cmp(ecparams.n)||0<=s.cmp(ecparams.n))throw Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);signature=Buffer.from(signature);1===s.cmp(ec.nh)&&ecparams.n.sub(s).toArrayLike(Buffer,"be",32).copy(signature,32);return signature};exports.signatureExport=function(signature){var r=signature.slice(0,32);signature=signature.slice(32,64);if(0<=(new BN(r)).cmp(ecparams.n)||0<=
(new BN(signature)).cmp(ecparams.n))throw Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);return{r:r,s:signature}};exports.signatureImport=function(sigObj){var r=new BN(sigObj.r);0<=r.cmp(ecparams.n)&&(r=new BN(0));sigObj=new BN(sigObj.s);0<=sigObj.cmp(ecparams.n)&&(sigObj=new BN(0));return Buffer.concat([r.toArrayLike(Buffer,"be",32),sigObj.toArrayLike(Buffer,"be",32)])};exports.sign=function(message,privateKey,noncefn,data){if("function"===typeof noncefn){var getNonce=noncefn;noncefn=function(counter){counter=
getNonce(message,privateKey,null,data,counter);if(!Buffer.isBuffer(counter)||32!==counter.length)throw Error(messages.ECDSA_SIGN_FAIL);return new BN(counter)}}var d=new BN(privateKey);if(0<=d.cmp(ecparams.n)||d.isZero())throw Error(messages.ECDSA_SIGN_FAIL);noncefn=ec.sign(message,privateKey,{canonical:!0,k:noncefn,pers:data});return{signature:Buffer.concat([noncefn.r.toArrayLike(Buffer,"be",32),noncefn.s.toArrayLike(Buffer,"be",32)]),recovery:noncefn.recoveryParam}};exports.verify=function(message,
signature,publicKey){signature={r:signature.slice(0,32),s:signature.slice(32,64)};var sigr=new BN(signature.r),sigs=new BN(signature.s);if(0<=sigr.cmp(ecparams.n)||0<=sigs.cmp(ecparams.n))throw Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);if(1===sigs.cmp(ec.nh)||sigr.isZero()||sigs.isZero())return!1;publicKey=loadPublicKey(publicKey);if(null===publicKey)throw Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);return ec.verify(message,signature,{x:publicKey.pub.x,y:publicKey.pub.y})};exports.recover=function(message,
signature,recovery,compressed){signature={r:signature.slice(0,32),s:signature.slice(32,64)};var sigr=new BN(signature.r),sigs=new BN(signature.s);if(0<=sigr.cmp(ecparams.n)||0<=sigs.cmp(ecparams.n))throw Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);try{if(sigr.isZero()||sigs.isZero())throw Error();var point=ec.recoverPubKey(message,signature,recovery);return Buffer.from(point.encode(!0,compressed))}catch(err){throw Error(messages.ECDSA_RECOVER_FAIL);}};exports.ecdh=function(publicKey,privateKey){publicKey=
exports.ecdhUnsafe(publicKey,privateKey,!0);return createHash("sha256").update(publicKey).digest()};exports.ecdhUnsafe=function(publicKey,privateKey,compressed){publicKey=loadPublicKey(publicKey);if(null===publicKey)throw Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);privateKey=new BN(privateKey);if(0<=privateKey.cmp(ecparams.n)||privateKey.isZero())throw Error(messages.ECDH_FAIL);return Buffer.from(publicKey.pub.mul(privateKey).encode(!0,compressed))}}
//# sourceMappingURL=module$node_modules$secp256k1$lib$elliptic$index.js.map
