{
"version":3,
"file":"module$node_modules$lodash$_composeArgs.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,wCAAA,CAA4D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAEpG,IAAIC,UAAYC,IAAAC,IAqChBJ,OAAAC,QAAA,CAxBAI,QAAoB,CAACC,IAAD,CAAOC,QAAP,CAAiBC,OAAjB,CAA0BC,SAA1B,CAAqC,CAAA,IACnDC,UAAa,EADsC,CAEnDC,WAAaL,IAAAM,OAFsC,CAGnDC,cAAgBL,OAAAI,OAHmC,CAInDE,UAAa,EAJsC,CAKnDC,WAAaR,QAAAK,OALsC,CAMnDI,YAAcd,SAAA,CAAUS,UAAV,CAAuBE,aAAvB,CAAsC,CAAtC,CANqC,CAOnDI,OAASC,KAAA,CAAMH,UAAN,CAAmBC,WAAnB,CAGb,KAFIG,SAEJ,CAFkB,CAACV,SAEnB,CAAO,EAAEK,SAAT,CAAqBC,UAArB,CAAA,CACEE,MAAA,CAAOH,SAAP,CAAA,CAAoBP,QAAA,CAASO,SAAT,CAEtB,KAAA,CAAO,EAAEJ,SAAT,CAAqBG,aAArB,CAAA,CACE,GAAIM,SAAJ;AAAmBT,SAAnB,CAA+BC,UAA/B,CACEM,MAAA,CAAOT,OAAA,CAAQE,SAAR,CAAP,CAAA,CAA6BJ,IAAA,CAAKI,SAAL,CAGjC,KAAA,CAAOM,WAAA,EAAP,CAAA,CACEC,MAAA,CAAOH,SAAA,EAAP,CAAA,CAAsBR,IAAA,CAAKI,SAAA,EAAL,CAExB,OAAOO,OArBgD,CAf2C;",
"sources":["node_modules/lodash/_composeArgs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$lodash$_composeArgs\"] = function(global,require,module,exports) {\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates an array that is the composition of partially applied arguments,\n * placeholders, and provided arguments into a single array of arguments.\n *\n * @private\n * @param {Array} args The provided arguments.\n * @param {Array} partials The arguments to prepend to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @params {boolean} [isCurried] Specify composing for a curried function.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgs(args, partials, holders, isCurried) {\n  var argsIndex = -1,\n      argsLength = args.length,\n      holdersLength = holders.length,\n      leftIndex = -1,\n      leftLength = partials.length,\n      rangeLength = nativeMax(argsLength - holdersLength, 0),\n      result = Array(leftLength + rangeLength),\n      isUncurried = !isCurried;\n\n  while (++leftIndex < leftLength) {\n    result[leftIndex] = partials[leftIndex];\n  }\n  while (++argsIndex < holdersLength) {\n    if (isUncurried || argsIndex < argsLength) {\n      result[holders[argsIndex]] = args[argsIndex];\n    }\n  }\n  while (rangeLength--) {\n    result[leftIndex++] = args[argsIndex++];\n  }\n  return result;\n}\n\nmodule.exports = composeArgs;\n\n};"],
"names":["shadow$provide","global","require","module","exports","nativeMax","Math","max","composeArgs","args","partials","holders","isCurried","argsIndex","argsLength","length","holdersLength","leftIndex","leftLength","rangeLength","result","Array","isUncurried"]
}
