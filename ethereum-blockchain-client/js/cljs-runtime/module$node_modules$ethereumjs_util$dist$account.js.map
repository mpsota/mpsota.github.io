{
"version":3,
"file":"module$node_modules$ethereumjs_util$dist$account.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/ethereumjs-util/dist/account.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$ethereumjs_util$dist$account\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert = require('assert');\nvar ethjsUtil = require('ethjs-util');\nvar secp256k1 = require('secp256k1');\nvar BN = require(\"bn.js\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\n/**\n * Returns a zero address.\n */\nexports.zeroAddress = function () {\n    var addressLength = 20;\n    var addr = bytes_1.zeros(addressLength);\n    return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (address) {\n    return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */\nexports.isZeroAddress = function (address) {\n    var zeroAddr = exports.zeroAddress();\n    return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details, consult EIP-1191.\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\nexports.toChecksumAddress = function (address, eip1191ChainId) {\n    address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n    var hash = hash_1.keccak(prefix + address).toString('hex');\n    var ret = '0x';\n    for (var i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\n    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n    from = bytes_1.toBuffer(from);\n    var nonceBN = new BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return hash_1.rlphash([from, null]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n    var fromBuf = bytes_1.toBuffer(from);\n    var saltBuf = bytes_1.toBuffer(salt);\n    var initCodeBuf = bytes_1.toBuffer(initCode);\n    assert(fromBuf.length === 20);\n    assert(saltBuf.length === 32);\n    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\n    return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */\nexports.isPrecompiled = function (address) {\n    var a = bytes_1.unpad(address);\n    return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n    return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    pubKey = bytes_1.toBuffer(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n    }\n    assert(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n    privateKey = bytes_1.toBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n    publicKey = bytes_1.toBuffer(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n    }\n    return publicKey;\n};\n//# sourceMappingURL=account.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","Object","defineProperty","value","assert","ethjsUtil","secp256k1","BN","bytes_1","hash_1","zeroAddress","exports.zeroAddress","addr","zeros","addressLength","bufferToHex","isValidAddress","exports.isValidAddress","address","test","isZeroAddress","exports.isZeroAddress","zeroAddr","addHexPrefix","toChecksumAddress","exports.toChecksumAddress","eip1191ChainId","stripHexPrefix","toLowerCase","hash","keccak","undefined","prefix","toString","ret","i","length","parseInt","toUpperCase","isValidChecksumAddress","exports.isValidChecksumAddress","generateAddress","exports.generateAddress","from","nonce","toBuffer","nonceBN","isZero","rlphash","slice","toArray","generateAddress2","exports.generateAddress2","salt","initCode","fromBuf","saltBuf","initCodeBuf","keccak256","concat","isPrecompiled","exports.isPrecompiled","a","unpad","isValidPrivate","exports.isValidPrivate","privateKey","privateKeyVerify","isValidPublic","exports.isValidPublic","publicKey","sanitize","publicKeyVerify","pubToAddress","exports.pubToAddress","pubKey","publicKeyConvert","publicToAddress","privateToAddress","exports.privateToAddress","privateToPublic","exports.privateToPublic","publicKeyCreate","importPublic","exports.importPublic"]
}
