shadow$provide.module$node_modules$ethereumjs_util$dist$object=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var assert=require("module$node_modules$assert$assert"),ethjsUtil=require("module$node_modules$ethjs_util$lib$index"),rlp=require("module$node_modules$rlp$dist$index"),bytes_1=require("module$node_modules$ethereumjs_util$dist$bytes");exports.defineProperties=function(self,
fields,data){self.raw=[];self._fields=[];self.toJSON=function(label){void 0===label&&(label=!1);if(label){var obj_1={};self._fields.forEach(function(field){obj_1[field]="0x"+self[field].toString("hex")});return obj_1}return bytes_1.baToJSON(self.raw)};self.serialize=function(){return rlp.encode(self.raw)};fields.forEach(function(field,i){function getter(){return self.raw[i]}function setter(v){v=bytes_1.toBuffer(v);"00"!==v.toString("hex")||field.allowZero||(v=Buffer.allocUnsafe(0));field.allowLess&&
field.length?(v=bytes_1.stripZeros(v),assert(field.length>=v.length,"The field "+field.name+" must not have more "+field.length+" bytes")):field.allowZero&&0===v.length||!field.length||assert(field.length===v.length,"The field "+field.name+" must have byte length of "+field.length);self.raw[i]=v}self._fields.push(field.name);Object.defineProperty(self,field.name,{enumerable:!0,configurable:!0,get:getter,set:setter});field.default&&(self[field.name]=field.default);field.alias&&Object.defineProperty(self,
field.alias,{enumerable:!1,configurable:!0,set:setter,get:getter})});if(data)if("string"===typeof data&&(data=Buffer.from(ethjsUtil.stripHexPrefix(data),"hex")),Buffer.isBuffer(data)&&(data=rlp.decode(data)),Array.isArray(data)){if(data.length>self._fields.length)throw Error("wrong number of fields in data");data.forEach(function(d,i){self[self._fields[i]]=bytes_1.toBuffer(d)})}else if("object"===typeof data){var keys_1=Object.keys(data);fields.forEach(function(field){-1!==keys_1.indexOf(field.name)&&
(self[field.name]=data[field.name]);-1!==keys_1.indexOf(field.alias)&&(self[field.alias]=data[field.alias])})}else throw Error("invalid data");}}
//# sourceMappingURL=module$node_modules$ethereumjs_util$dist$object.js.map
